---
layout: post
title:  "Cpp 기본 개념 학습_1"
date:   2017-07-03 11:32:00
categories: [Cpp]
tags: study cpp
comments: true
---
<!--more-->
<h2>"C언어 기반의 C++"</h2>  

C++언어, 앞으로는 편하게 Cpp라 하겠다. 기본적으로 내가 하고 싶은 것들은 Cpp로 짜야하는데 학과 커리큘럼에 없어 따로 학습하려고 한다. 물론 기본 이론에 대한 학습은 이미 한, 두 차례 진행했지만 시간이 흘러 잊혀진 감이 없잖아 있다. 그래서 이번 학습을 통해 다시 한 번 학습하고 이후나 이외의 다른 이들이 학습할 수 있도록 기본기 위주로 이야기하고자 한다.  

우선 'Cpp 기본 개념 학습'에서는 C언어를 어느정도 알고 있다고 생각하고 진행하려고 하니 C언어에 대한 기본적인 내용을 모른다면 다소 어려울 수 있다. 이 점을 참고하고 함께 학습하도록 하자.  

---

이름에서도 알 수 있는 것처럼 Cpp은 C언어의 연장선이라고 생각하면 되겠다. 사실 연장선이라고 하기에 C언어로 된 절차지향적 프로그램들이 아직 남아있으니 '파생된 것'이라고 이해하면 좋겠다. 기본적으로 Cpp 컴파일러는 C언어로 작성된 대부분의 프로그램을 컴파일 할 수 있다. 그러나 Cpp은 C가 지니지 않는 문법적 특성도 제법 지니고 있다. (이 중에서 일부는 객체지향적 특성의 반영을 위해 C의 문법 구조가 자연스럽게 진화한 형태로 존재하는 것도 있음을 참고하자.)  

그래서 이번 게시글에서는 이러한 기본적인 Cpp의 특성을 몇 가지 살펴보고자한다.  
  
---
우리는 어떤 언어를 학습하고자 할 때 가장 처음 외치는 문자열이 있다. "Hello, World!"란 문자열말이다. (여담void 이지만 학과 교수님 중에는 1학년이 이해하지 못한다고 "안녕, 세계!"라고 해석해주는 교수님이 계신다)  

그렇다면 C와의 차이는 무엇일까? 아래 예제를 보고 차이를 찾아보자.

{% highlight C %}
#include <stdio.h>  

int main() {  

printf("Hello, World!");  

return 0;
}
{% endhighlight %}
  
{% highlight Cpp %}
#include <iostream>  

int main (void) {  

std::cout<<"Hello, Woruld!"<<std::endl;  

return 0;
}
{% endhighlight %}

위 두 구문의 차이가 느껴지는가? 그럼 차이점을 기반으로 C와 다른 아래 3가지 Cpp의 문법적 특성을 살펴보자.  

1. 헤더파일의 선언 부분
2. 출력 부분
3. 개행 부분  

---
  
  

<h4>1. 헤더파일의 선언 부분</h4>  

이해가 안가는 다른 부분이 많겠지만 천천히 전처리부분부터 살펴보자. 우선 C와 Cpp에서 선언한 헤더파일의 용도는 '표준 입출력'에 대한 것이다. C에서의 표준 입출력(printf, scanf 등)을 사용하기 위해 <stddio.h>를 선언했다면 Cpp에서의 표준 입출력(std::cout, std::cin 등)을 사용하기 위해 <iostram>을 선언해야한다. 그렇다면 여기서 다음과 같은 의문이 들 것이다. 'Cpp에서는 헤더파일 선언 시에 확장자 입력이 필요없나요?'  여기에 대한 답은 '필요있다!'이다. <iostram>에 확장자가 없는 것은 Cpp에서 표준 헤더 파일의 선언이기 때문이다. 또한 표준이 도입되기 전과 후를 나누기 위해 과거의 헤더파일에는 <iostram.h>과 같이 확장자 선언이 있다는 점을 참고하기 바란다.  
  
  
<h4>2. 출력 부분</h4>  

다음은 출력이다. C에서의 출력은 printf("Hello, World!");이고 Cpp의 출력은 std::cout<<"Hello, World!;"이다. 여기서 우리는 std라고 부르는 왠지 standard의 약어일 것만 같은 것이 신경쓰인다. 또한 cout을 보며 '코웃?'하며 고개를 갸우뚱할 수도 있다. (<<연산자는 나중에 언급하기로 하자.) 그렇다면 std는 무엇일까? 정답은 namespace라고 부르는 '이름의 충돌문제를 막기 위한 문법'이다. 프로그램이 대형화가 되면서 여러 회사들이 한 프로젝트에 참여하는 경우가 발생한다. 이럴 때 A사와 B사가 각자 업무를 나누고 일을 진행한다. 그러다 merege를 한다고 치자. 그럴 때 A사와 B사의 함수 이름이 같다면 십중팔구 둘 중 하나는 서로 다른 기능을 하는 같은 이름을 갖는 함수의 이름을 변경해야한다. 그렇다면 생각해보자. 큰 프로젝트에서 함수 이름 하나 바꾸는 게 말처럼 간단한 것은가.. 생각만해도 화가나는 상황이다. 그래서 Cpp은 namespace를 제공한다. std::cout은 cout은 cout인데 그게 속한 namespace가 std라는 것이다. 조금 이해가 됐는가? 그러면 넘어가자. 다음은 cout에 대한 이야기다. cout은 C의 out(출력)이다. cout! '코웃'이 아니라는 걸 알아두자. 또한 이 문법은 위에 사용된 것처럼 std::cout<<"출력 내용"로 사용된다. 그렇다면 선언된 변수의 경우에는 어떨까? 결과는 아래와 같다.  

{% highlight Cpp %}
#include <iostream>  

int main (void) {  

int var = 10;
std::cout<<var<<std::endl;
return 0;
}
{% endhighlight %}  

이처럼 사용하면 된다. 이 부분에서 또 다음과 같은 생각을 할 수 있다. "오.. 맙소사! 출력 포맷 지정을 하지 않아도 된다니!" 다소 호들갑을 떨었지만 새로운 문법 형태이니 놀라도 좋다. (어떻게 이런 형태로 사용하는 것이 가능한가에 대해서는 다음에 설명하겠다.)  
  
  
<h4>3. 개행 부분</h4>  
  
다음은 개행이다. 우리는 일반적으로 '입력은 자동으로 개행되지만 출력은 '\n'을 사용해야하지!'라고 알고 있을 것이다. 그래서 Cpp에서는 문자열에 '\n'을 대신해 <<std::endl을 표준으로 제공한다. (엔들이 아니라 end l(line)이다. 또한 아직까지 << 연산자가 무얼하는 것인가에 대해서는 학습하지 않았다. 이에 대한 궁금증은 다음에 다루도록하자.)

정리하자면 아래와 같다.  

1. 표준 헤더 파일의 경우에는 선언 시 확장자를 생략해도 좋다.
2. 출력은 std::cout<<'출력 내용' 과 같이 사용하면 된다. 또한 std는 namespace이다.
3. 개행은 <<std::endl이 수행해준다.

의문점
1. <<연산자는 뭐지?
2. namespace는 뭐지?
3. 왜 출력 포맷을 지정하지 않아도 출력이 되는 거지?  

  
의문점은 차차 풀어보도록 하자.

---

다음에 살펴볼 코드는 아래와 같다.  

{% highlight C %}
#include <stdio.h>  

int main (void) {  

int val1, val2, result =0;  

printf("첫 번째 숫자 입력: ");
scanf("%d", &val1);  

printf("두 번째 숫자 입력: ");
scanf("%d", &val2);  

result = val1 + val2;
printf("덧셈 결과: %d\n", result);  

return 0;
}
{% endhighlight %}

{% highlight Cpp %}
#include <iostream>  

int main (void) {  

int val1 = 0;
std::cout<"첫 번재 숫자 입력: ";
std::cin>>val1;  

int val2 = 0;
std::cout<"두 번재 숫자 입력: ";
std::cin>>val2;  

int result = val1 + val2;
std::cout<<"덧셈 결과: "<<result<<std::endl;
return 0;
}
{% endhighlight %}  

이전의 예제와 마찬가지로 위 코드를 통해서 우리는 아래와 같은 3가지가 다르다는 것을 알 수 있다.  
1. 변수 선언 부분
2. 입력 부분
3. 변수 출력 부분

---  

<h4>1. 변수 선언 부분</h4>

<h4>2. 입력 부분</h4>

<h4>3. 변수 출력 부분</h4>