---
layout: post
title: 알고리즘의 성능 [시간복잡도와 공간복잡도]
excerpt: "알고리즘 문제를 풀다보면 공간복잡도와 시간복잡도가 조건으로 주어지는 많다. 공간복잡도는 무엇이고 시간복잡도는 무엇인지 알아보고 정리해보는 시간을 가지려 한다. "
categories: [알고리즘]
comments: true
---

## 들어가기에 앞서...

알고리즘 문제를 풀다보면 공간복잡도와 시간복잡도가 조건으로 주어지는 문제들을 심심찮게 보게 됩니다. 알고리즘 트레이닝 사이트에서 문제를 풀다 보면  과연 내가 짠 알고리즘이 맞는 걸까? 라는 의구심이 들게 됩니다. 조금만 어려운 문제에 맞닥들여도 두려움부터 앞서고 머리가 찌끈찌끈 아파오는 알고리즘... 기초부터 탄탄하게 파헤쳐 봅시다!

아래는 알고리즘 트레이닝 사이트에서 문제를 풀다보면 종종 확인할 수 있는 문구 입니다.

![시간 및 공간복잡도](https://user-images.githubusercontent.com/20435620/29495553-b53cf4f8-85fc-11e7-8cf0-a916e24af6ad.png)


## 알고리즘 기초

저번 시간에는 알고리즘이 무엇이고 프로그램을 개발 할 때 알고리즘의 중요성에 대해 다뤄봤습니다.
오늘은 *알고리즘의 성능* 을 분석(?) 평가(?)하는 방법인 *시간복잡도* 와 *공간복잡도* 에 대해 정리를 한번 해보는 시간을 가지려고 합니다.


## 알고리즘의 성능

어떤 알고리즘을 사용하느냐에 따라서 프로그램의 **속도가 빠르고 메모리가 적게든다.**

하드웨어의 엄청난 발전속도로 인해 요즘은 생산성이 중요시 여겨지는 시대라고 하지만 계산속도와 메모리를 생각하지 않고 프로그램을 짜면

유지 보수 관리 차원에서 전체적으로 손을 봐야 되는 현상이 발생한다고 한다.

아래 나와있는 코드를 비교해보자.

**과연 어떤게 좋은 프로그램일까요?**

[1] System.out.println 으로 Hello World 를 10번 찍은 소스코드

{% highlight css %}
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
    System.out.println("Hello World");
{% endhighlight %}

[2] for 문을 돌려 Hello World 를 10번 찍은 소스코드

{% highlight css %}
    for (int i = 0; i <= 10; i++) {
      System.out.println("Hello World");
    }
{% endhighlight %}

자바의 기초를 아시는 분이라면 당연 [2] 번 for문을 활용한 프로그램을 쉽게 고르실 겁니다.

하지만, 연산속도로만 보자면 첫번째 코드가 더 빠릅니다.

그럼 왜 [2] 번이 좋은 프로그램일까요?

*System.out.println("Hello World");* 를 10번이 아니라 100000000만 번 찍는 프로그램으로 변경 해야 될 경우 어떻게 될까요?

실제 명령어가 수십만 또는 수억줄이 될 수도 있겠죠?

프로그램이 훨씬 무거워 지게 됩니다.

**즉, 효율적인 알고리즘이란 시작하여 결과가 나올 때까지의 실행시간이 짧으면서 메모리의 자원을 덜 사용하는 알고리즘이 효율적인 알고리즘입니다.**

그럼 알고리즘의 성능은 어떻게 판단할까요?

아래 시간복잡도와 공간복잡도라는 개념을 알고 복잡도 분석 방법을 아셔야 됩니다.


## 시간복잡도 (Time Complexity) 란?

시간복잡도는 간단하게 말하면, 알고리즘을 평가하는데에 있어 수행시간을 분석하여 결과를 도출해내는 겁니다.

절대적인 실행 시간을 나타내는 것은 아니고, 알고리즘을 이루고 있는 연산들이 몇번이나 실행되는지를 숫자로 표시하는 겁니다.

즉, 연산의 횟수를 세고 처리해야 할 데이터의 수 n 에 대한 연산횟수의 함수 T(n)을 만들면 됩니다.



### 빅오 표기법 (Big-O Notation)

시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을

빅오 표기법(Big-O notation)이라고 한다.

빅오 표기법은 n의 값에 따른 함수의 상한 값을 나타내는 방법이다. 이론은 빅오표기법의 정의를 보면 알 수 있지만

귀찮으니 생략한다.

시간복잡도 함수가 f(n)=5  이면 O(1)이다.

시간복잡도 함수가 2n+1이면 O(n)이다.

시간복잡도 함수가 f(n) = 3n^+100 이면 O(n^)이다.

빅오 표기법을 사용하면 시간 복잡도 함수의 증가에 많이 기여하지 못하는 항을 생략함으로써 시간 복잡도를 간단한게 표시할 수 있다.

빅오표기법을 얻는 간단한 방법은 최고차 항만 남기고 다른 항들과 상수를 버리는것이다. 궁극적으로 최고차 항의 계수도 버리고 최고차 항의

차수만을 사용한다.

이처럼 최고차 항만 남기고 다른 항들과 상수를 버리는 것은 다른 항들과 상수는 시간 복잡도 함수의 증가에 많이 기여하지 못한다는 뜻이다

입력 값이 작을 때는 영향을 끼칠 수 있겠지만 입력값이 커지면 커질수록 다른항들이나 상수가 실행속도에 영향을 미치는 부분은 미비하다.

많이 쓰이는 빅오 표기법 (실행시간이 빠른 순)

* O(1) : 입력 자료의 수에 관계없이 일정한 실행 시간을 갖는 알고리즘 (상수형)
* O(log N) : 입력 자료의 크기가 N일경우 log2N 번만큼의 수행시간을 가진다. (로그형)
* O(N) : 입력 자료의 크기가 N일경우 N 번만큼의 수행시간을 가진다. (선형)
* O(N log N) : 입력 자료의 크기가 N일경우 N*(log2N) 번만큼의 수행시간을 가진다. (선형로그형)
* O(N2) : 입력 자료의 크기가 N일경우 N2 번만큼의 수행시간을 가진다. (2차형)
* O(N3) : 입력 자료의 크기가 N일경우 N3 번만큼의 수행시간을 가진다. (3차형)
* O(2n) : 입력 자료의 크기가 N일경우 2N 번만큼의 수행시간을 가진다. (지수형)
* O(n!) : 입력 자료의 크기가 N일경우 n*(n-1) * (n-2)... * 1(n!) 번만큼의 수행시간을 가진다. ex)외판원 문제(TSP)의 기본적인 해법(팩토리얼형)



## 공간복잡도 (Space Complexity) 란 ?
